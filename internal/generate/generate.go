// Package generate implements the code generator.
package generate

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"

	. "github.com/dave/jennifer/jen" //nolint:revive,stylecheck

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	parsedPatternsVarName = "parsedPatterns"
)

const httpatternpkg = "github.com/crewlinker/protohtml-go/internal/httppattern"

// parsedPatternsKey standardizes on the key name of the pre-parsed routes.
func parsedPatternsKey(svc *Service, route *Route) string {
	return fmt.Sprintf("%s.%s", svc.GoName, route.GoName)
}

// generateInit will perform logic when the package is initializing.
func generateInit(file *File, pkg *Package) error {
	file.Commentf("%s hold all parsed route patterns, done once when the package initializes", parsedPatternsVarName)
	file.Var().Id(parsedPatternsVarName).Op("=").Map(String()).Op("*").Qual(httpatternpkg, "Pattern").Values()

	block := []Code{}

	for _, svc := range pkg.Services {
		for _, route := range svc.Routes {
			block = append(block,
				Id("parsedPatterns").Index(Lit(parsedPatternsKey(svc, route))).
					Op("=").Qual(httpatternpkg, "MustParsePattern").Call(Lit(route.StrPattern)))
		}
	}

	file.Func().Id("init").Params().Block(block...)

	return nil
}

// generatePackage generates for a single package.
func generatePackage(w io.Writer, pkg *Package) error {
	file := NewFile(string(pkg.GoPackageName))
	file.HeaderComment("Code generated by protocgenpgxm. DO NOT EDIT.")

	if err := generateInit(file, pkg); err != nil {
		return fmt.Errorf("failed to generate init: %w", err)
	}

	if err := file.Render(w); err != nil {
		return fmt.Errorf("failed to render: %w", err)
	}

	return nil
}

// Generate generates protohtml code.
func Generate(plugin *protogen.Plugin) (map[string]*Package, error) {
	blueprint, err := preGenPlugin(plugin)
	if err != nil {
		return nil, fmt.Errorf("failed to pre-generate: %w", err)
	}

	pkgs := map[string]*Package{}
	for _, pkg := range blueprint.Packages {
		if pkg.IsEmpty() {
			continue // skip if empty.
		}

		fname := filepath.Join(pkg.Dir, string(pkg.GoPackageName), packageNameSuffix+".gen.go")
		fdata := bytes.NewBuffer(nil)

		if err := generatePackage(fdata, pkg); err != nil {
			return nil, fmt.Errorf("[%s] failed to generate: %w", pkg.GoPackageName, err)
		}

		pkg.Result = fdata
		pkgs[fname] = pkg
	}

	return pkgs, nil
}
